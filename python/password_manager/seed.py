"""Seed phrase verification and key derivation utilities.

The original web implementation derives a so-called "private key" by:

1. Mapping each mnemonic word to its BIP-39 index padded to four digits.
2. Concatenating those indices into one long decimal string.
3. Interpreting that decimal string as a big integer and converting it to
   hexadecimal.

This module replicates that behaviour so that passwords generated by the
desktop application match those from the web version.
"""

from pathlib import Path
import hashlib
import os
from typing import Dict, List, Optional
from cryptography.hazmat.primitives.asymmetric import ec
from .bech32 import encode_nsec

try:  # pragma: no cover - optional dependency
    from nostr.key import PrivateKey as NostrPrivateKey
except Exception:  # pragma: no cover - library may not be installed
    NostrPrivateKey = None  # type: ignore

WORDLIST_PATH = Path(__file__).resolve().parents[1] / "static" / "bip39_wordlist.txt"
with open(WORDLIST_PATH, "r", encoding="utf-8") as f:
    WORD_LIST: List[str] = [w.strip() for w in f if w.strip()]

WORD_SET = set(WORD_LIST)
WORD_INDEX: Dict[str, int] = {word: idx for idx, word in enumerate(WORD_LIST)}


def verify_seed_phrase(seed_phrase: str) -> bool:
    words = [w.strip() for w in seed_phrase.split()]
    if len(words) not in {12, 15, 18, 21, 24}:
        return False
    return all(word in WORD_SET for word in words)


def generate_seed_phrase(strength: int = 128) -> str:
    """Generate a BIP-39 seed phrase using the local wordlist.

    Args:
        strength: Entropy strength in bits. Must be one of 128, 160, 192, 224, or 256.

    Returns:
        A space-separated mnemonic seed phrase.
    """
    if strength not in {128, 160, 192, 224, 256}:
        raise ValueError("strength must be between 128 and 256 and divisible by 32")

    entropy = os.urandom(strength // 8)
    entropy_bits = "".join(f"{byte:08b}" for byte in entropy)

    hash_bits = hashlib.sha256(entropy).hexdigest()
    hash_bits = bin(int(hash_bits, 16))[2:].zfill(256)
    checksum_length = strength // 32
    checksum = hash_bits[:checksum_length]

    bits = entropy_bits + checksum
    words = [WORD_LIST[int(bits[i:i + 11], 2)] for i in range(0, len(bits), 11)]
    return " ".join(words)


def _words_to_indices(words: List[str]) -> str:
    """Convert mnemonic words to their padded index representation."""
    parts = []
    for word in words:
        idx = WORD_INDEX.get(word)
        if idx is None:
            raise ValueError(f"Word '{word}' not in BIP-39 wordlist")
        parts.append(f"{idx:04d}")
    return "".join(parts)


def _decimal_string_to_hex(decimal_str: str) -> str:
    """Convert a decimal string to hexadecimal without leading zeros."""
    return format(int(decimal_str, 10), "x")


def derive_private_key(seed_phrase: str) -> str:
    """Derive the web-compatible private key from a seed phrase."""
    words = [w.strip() for w in seed_phrase.split() if w.strip()]
    decimal = _words_to_indices(words)
    return _decimal_string_to_hex(decimal)


def derive_npub_from_nsec(nsec_hex: str) -> str:
    """Derive the Nostr public key (hex) from the ``nsec`` secret."""
    sk = ec.derive_private_key(int(nsec_hex, 16), ec.SECP256K1())
    pk_numbers = sk.public_key().public_numbers()
    return f"{pk_numbers.x:064x}"


def derive_keys(seed_phrase: str) -> dict:
    """Return key material matching the web implementation.

    The returned dictionary contains the web private key, the derived
    ``nsec`` secret, the corresponding ``npub`` public key and, when the
    optional :mod:`python-nostr` library is available, an instantiated
    :class:`nostr.key.PrivateKey` object for high level operations.
    """

    private_key = derive_private_key(seed_phrase)
    nsec = hashlib.sha256(private_key.encode()).hexdigest()
    npub = derive_npub_from_nsec(nsec)
    # Try to instantiate a python-nostr PrivateKey only if the library is
    # available and exposes a compatible constructor. Some versions do not
    # provide `from_hex`, so we guard access and fall back gracefully.
    nostr_priv: Optional[NostrPrivateKey] = None
    if NostrPrivateKey:
        try:
            if hasattr(NostrPrivateKey, "from_nsec"):
                nostr_priv = NostrPrivateKey.from_nsec(encode_nsec(nsec))
            elif hasattr(NostrPrivateKey, "from_hex"):
                nostr_priv = NostrPrivateKey.from_hex(nsec)
            else:
                try:
                    nostr_priv = NostrPrivateKey(bytes.fromhex(nsec))  # type: ignore[arg-type]
                except Exception:
                    nostr_priv = None
        except Exception:
            nostr_priv = None
    return {
        "private_key": private_key,
        "nsec": nsec,
        "npub": npub,
        "nostr_private": nostr_priv,
    }
