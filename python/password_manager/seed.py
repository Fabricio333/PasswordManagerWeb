"""Seed phrase verification and key derivation utilities.

The original web implementation derives a so-called "private key" by:

1. Mapping each mnemonic word to its BIP-39 index padded to four digits.
2. Concatenating those indices into one long decimal string.
3. Interpreting that decimal string as a big integer and converting it to
   hexadecimal.

This module replicates that behaviour so that passwords generated by the
desktop application match those from the web version.
"""

from pathlib import Path
import hashlib
from typing import Dict, List
from cryptography.hazmat.primitives.asymmetric import ec

WORDLIST_PATH = Path(__file__).resolve().parents[1] / "static" / "bip39_wordlist.txt"
with open(WORDLIST_PATH, "r", encoding="utf-8") as f:
    WORD_LIST: List[str] = [w.strip() for w in f if w.strip()]

WORD_SET = set(WORD_LIST)
WORD_INDEX: Dict[str, int] = {word: idx for idx, word in enumerate(WORD_LIST)}


def verify_seed_phrase(seed_phrase: str) -> bool:
    words = [w.strip() for w in seed_phrase.split()]
    if len(words) not in {12, 15, 18, 21, 24}:
        return False
    return all(word in WORD_SET for word in words)


def _words_to_indices(words: List[str]) -> str:
    """Convert mnemonic words to their padded index representation."""
    parts = []
    for word in words:
        idx = WORD_INDEX.get(word)
        if idx is None:
            raise ValueError(f"Word '{word}' not in BIP-39 wordlist")
        parts.append(f"{idx:04d}")
    return "".join(parts)


def _decimal_string_to_hex(decimal_str: str) -> str:
    """Convert a decimal string to hexadecimal without leading zeros."""
    return format(int(decimal_str, 10), "x")


def derive_private_key(seed_phrase: str) -> str:
    """Derive the web-compatible private key from a seed phrase."""
    words = [w.strip() for w in seed_phrase.split() if w.strip()]
    decimal = _words_to_indices(words)
    return _decimal_string_to_hex(decimal)


def derive_npub_from_nsec(nsec_hex: str) -> str:
    """Derive the Nostr public key (hex) from the ``nsec`` secret."""
    sk = ec.derive_private_key(int(nsec_hex, 16), ec.SECP256K1())
    pk_numbers = sk.public_key().public_numbers()
    return f"{pk_numbers.x:064x}"


def derive_keys(seed_phrase: str) -> dict:
    private_key = derive_private_key(seed_phrase)
    nsec = hashlib.sha256(private_key.encode()).hexdigest()
    npub = derive_npub_from_nsec(nsec)
    return {"private_key": private_key, "nsec": nsec, "npub": npub}
